# Task Pipeline System - Technical Specification

**Version:** 1.0
**Created:** 2025-11-06
**Owner:** Emma (Scout) + Inna (Specifier)
**Purpose:** Complete specification for automatic mission pipeline and task creation

---

## Executive Summary

**What:** When a job is won, automatically create the entire mission pipeline with all tasks, dependencies, and assignments.

**Why:** Eliminates manual task creation. Everyone immediately knows their role in the new mission.

**How:** "Job Won" button click â†’ Create mission node â†’ Create pipeline tasks â†’ Encode dependencies â†’ Send notifications

---

## Mission State Machine

### States

```
LEAD_FOUND â†’ PROPOSAL_DRAFT â†’ PROPOSAL_REVIEW â†’ PROPOSAL_SENT â†’ JOB_WON
   â†“
SPEC_WRITING â†’ SPEC_REVIEW â†’ IMPLEMENTATION â†’ DEPLOYMENT â†’ QA_TESTING
   â†“
QA_PASSED â†’ CLIENT_DELIVERY â†’ COMPLETE
```

### State Definitions

| State | Description | Who | Exit Condition |
|-------|-------------|-----|----------------|
| `LEAD_FOUND` | Emma found Upwork job | Emma | Emma clicks "Analyze Job" |
| `PROPOSAL_DRAFT` | Emma drafts proposal | Emma | Emma clicks "Ready for Review" |
| `PROPOSAL_REVIEW` | Human reviews proposal | Bigbosexf | Clicks "Approve" or "Needs Revision" |
| `PROPOSAL_SENT` | Proposal sent to client | Bigbosexf | Client responds (won/lost) |
| `JOB_WON` | Client accepts proposal | â€” | Auto-transition to SPEC_WRITING |
| `SPEC_WRITING` | Reanance writes specs | Reanance | Clicks "Spec Complete" |
| `SPEC_REVIEW` | Inna verifies specs | Inna | Clicks "Spec Locked" |
| `IMPLEMENTATION` | Kara implements code | Kara | Clicks "Ready to Deploy" |
| `DEPLOYMENT` | Kara deploys to production | Kara | Deployment succeeds |
| `QA_TESTING` | Bigbosexf tests deployment | Bigbosexf | Clicks "QA Pass" or "Bugs Found" |
| `QA_PASSED` | All tests pass | â€” | Auto-transition to CLIENT_DELIVERY |
| `CLIENT_DELIVERY` | Reanance delivers to client | Reanance | Client accepts delivery |
| `COMPLETE` | Mission done, payment received | â€” | Terminal state |

### Revision Loops

**Proposal Revision Loop:**
```
PROPOSAL_REVIEW â†’ "Needs Revision" â†’ PROPOSAL_DRAFT â†’ PROPOSAL_REVIEW
```

**Bug Fix Loop:**
```
QA_TESTING â†’ "Bugs Found" â†’ IMPLEMENTATION â†’ DEPLOYMENT â†’ QA_TESTING
```

**Spec Clarification Loop:**
```
IMPLEMENTATION â†’ "Ask Question" â†’ SPEC_WRITING â†’ IMPLEMENTATION
```

---

## Auto-Task Creation Rules

### Trigger: Job Won Button

**Button:** "Job Won" (appears in Emma's proposal notification)

**When clicked:**
1. Create `U4_Mission` node
2. Create 8 pipeline tasks (U4_Work_Item nodes)
3. Encode task dependencies (U4_DEPENDS_ON links)
4. Send notifications to assigned team members
5. Reply to button click: "âœ… Mission created: {mission_name}. Team notified."

---

## Pipeline Task Template

### Task 1: Write Specification

```python
{
    "name": f"Write spec for Mission #{mission_id}",
    "work_type": "specification",
    "priority": "high",
    "state": "todo",  # Active immediately
    "assignee_ref": "reanance",
    "mission_ref": mission_id,
    "pipeline_stage": "SPEC_WRITING",
    "acceptance_criteria": "Complete 6-level docs (PATTERN â†’ GUIDE)",
    "due_date": datetime.now() + timedelta(days=2),
    "estimated_effort": "4h"
}
```

**Dependencies:** None (can start immediately)

**Blocks:** Task 2 (Implementation cannot start until spec done)

---

### Task 2: Implement Mission

```python
{
    "name": f"Implement Mission #{mission_id}",
    "work_type": "implementation",
    "priority": "high",
    "state": "waiting",  # Blocked until Task 1 completes
    "assignee_ref": "kara",
    "mission_ref": mission_id,
    "pipeline_stage": "IMPLEMENTATION",
    "acceptance_criteria": "All code generated by Rafael, tested locally",
    "due_date": datetime.now() + timedelta(days=5),
    "estimated_effort": "8h"
}
```

**Dependencies:** Task 1 (depends on spec)

**Blocks:** Task 3 (Deployment cannot happen until code ready)

---

### Task 3: Deploy to Production

```python
{
    "name": f"Deploy Mission #{mission_id}",
    "work_type": "deployment",
    "priority": "high",
    "state": "waiting",  # Blocked until Task 2 completes
    "assignee_ref": "kara",
    "mission_ref": mission_id,
    "pipeline_stage": "DEPLOYMENT",
    "acceptance_criteria": "Live URL accessible, health check passes",
    "due_date": datetime.now() + timedelta(days=6),
    "estimated_effort": "2h"
}
```

**Dependencies:** Task 2 (depends on implementation)

**Blocks:** Task 4 (QA cannot test until deployed)

---

### Task 4: QA Testing

```python
{
    "name": f"QA test Mission #{mission_id}",
    "work_type": "qa",
    "priority": "high",
    "state": "waiting",  # Blocked until Task 3 completes
    "assignee_ref": "bigbosexf",
    "mission_ref": mission_id,
    "pipeline_stage": "QA_TESTING",
    "acceptance_criteria": "All DoD items verified, no critical bugs",
    "due_date": datetime.now() + timedelta(days=7),
    "estimated_effort": "3h"
}
```

**Dependencies:** Task 3 (depends on deployment)

**Blocks:** Task 5 (Delivery cannot happen until QA passes)

---

### Task 5: Client Delivery

```python
{
    "name": f"Deliver Mission #{mission_id} to client",
    "work_type": "delivery",
    "priority": "high",
    "state": "waiting",  # Blocked until Task 4 completes
    "assignee_ref": "reanance",
    "mission_ref": mission_id,
    "pipeline_stage": "CLIENT_DELIVERY",
    "acceptance_criteria": "Evidence Sprint demo sent, credentials handed off",
    "due_date": datetime.now() + timedelta(days=8),
    "estimated_effort": "1h"
}
```

**Dependencies:** Task 4 (depends on QA pass)

**Blocks:** Task 6 (Follow-up cannot happen until delivered)

---

### Task 6: Post-Delivery Follow-up

```python
{
    "name": f"Post-delivery check-in: Mission #{mission_id}",
    "work_type": "follow_up",
    "priority": "medium",
    "state": "waiting",  # Blocked until Task 5 completes
    "assignee_ref": "reanance",
    "mission_ref": mission_id,
    "pipeline_stage": "COMPLETE",
    "acceptance_criteria": "Client feedback received, testimonial requested",
    "due_date": datetime.now() + timedelta(days=15),  # 7 days after delivery
    "estimated_effort": "30m"
}
```

**Dependencies:** Task 5 (depends on delivery) + 7-day delay

**Blocks:** None (final task)

---

### Task 7: Proposal Review (Created Before Job Won)

```python
{
    "name": f"Review proposal for Job #{job_id}",
    "work_type": "review",
    "priority": "high",
    "state": "todo",  # Active immediately when Emma finishes draft
    "assignee_ref": "bigbosexf",
    "mission_ref": None,  # Not yet a mission (still a lead)
    "pipeline_stage": "PROPOSAL_REVIEW",
    "acceptance_criteria": "Budget verified, proposal approved",
    "due_date": datetime.now() + timedelta(hours=4),  # Urgent
    "estimated_effort": "15m"
}
```

**Note:** This task is created when Emma clicks "Ready for Review" on proposal, NOT when job is won.

---

### Task 8: Spec Review (Optional Milestone)

```python
{
    "name": f"Review spec for Mission #{mission_id}",
    "work_type": "review",
    "priority": "high",
    "state": "waiting",  # Blocked until Task 1 completes
    "assignee_ref": "inna",  # Inna citizen reviews (via human)
    "mission_ref": mission_id,
    "pipeline_stage": "SPEC_REVIEW",
    "acceptance_criteria": "All 6 docs complete, AC.md locked",
    "due_date": datetime.now() + timedelta(days=3),
    "estimated_effort": "1h"
}
```

**Dependencies:** Task 1 (depends on spec writing)

**Blocks:** Task 2 (Implementation waits for spec lock)

**Note:** Optional - may be skipped if spec is simple.

---

## Dependency Encoding

### U4_DEPENDS_ON Relationship

**Schema:**
```python
{
    "criticality": "blocking" | "preferred" | "optional",
    "created_at": datetime,
    "reason": str  # Why this dependency exists
}
```

**Example:**
```cypher
// Task 2 (Implementation) depends on Task 1 (Spec)
MATCH (impl:U4_Work_Item {name: "Implement Mission #47"})
MATCH (spec:U4_Work_Item {name: "Write spec for Mission #47"})
CREATE (impl)-[:U4_DEPENDS_ON {
    criticality: "blocking",
    reason: "Cannot implement without spec"
}]->(spec)
```

### Criticality Levels

| Level | Meaning | Blocking? |
|-------|---------|-----------|
| `blocking` | Hard dependency - MUST complete first | Yes |
| `preferred` | Should complete first, but can start in parallel | No |
| `optional` | Nice to have, but not required | No |

### Automatic Activation Logic

**When a task completes:**
1. Find all tasks with `U4_DEPENDS_ON` link pointing to completed task
2. Check if ALL blocking dependencies are complete
3. If yes: `SET dependent_task.state = 'todo'` (activate)
4. If no: Keep in `waiting` state

**Cypher query:**
```cypher
// Task just completed
MATCH (completed:U4_Work_Item {id: $task_id})
SET completed.state = 'complete', completed.completed_at = datetime()

// Find dependent tasks
MATCH (completed)<-[dep:U4_DEPENDS_ON]-(dependent:U4_Work_Item)
WHERE dependent.state = 'waiting'

// Check if all blocking dependencies are complete
WITH dependent
MATCH (dependent)-[:U4_DEPENDS_ON {criticality: 'blocking'}]->(blocker:U4_Work_Item)
WITH dependent, collect(blocker.state) AS blocker_states
WHERE all(state IN blocker_states WHERE state = 'complete')

// Activate task
SET dependent.state = 'todo'
RETURN dependent.name AS activated_tasks
```

---

## Revision Loop Handling

### Pattern 1: Proposal Needs Revision

**Trigger:** Bigbosexf clicks "Needs Revision" button on proposal review task

**Flow:**
```python
# 1. Prompt for revision reason
await bot.send_message(
    chat_id=bigbosexf_id,
    text="What needs revision?",
    reply_markup=ForceReply()
)

# 2. User types: "Budget too high, reduce to $600"
revision_reason = await get_user_response()

# 3. Create revision task
revision_task = create_task({
    "name": f"Revise proposal for Job #{job_id}",
    "work_type": "revision",
    "priority": "high",
    "state": "todo",
    "assignee_ref": "emma",
    "pipeline_stage": "PROPOSAL_DRAFT",
    "acceptance_criteria": "Budget adjusted per feedback",
    "revision_reason": revision_reason
})

# 4. Block original review task
graph.execute(f"""
    MATCH (review:U4_Work_Item {{name: "Review proposal for Job #{job_id}"}})
    MATCH (revision:U4_Work_Item {{name: "Revise proposal for Job #{job_id}"}})
    CREATE (review)-[:U4_BLOCKED_BY {{reason: revision_reason}}]->(revision)
    SET review.state = 'blocked'
""")

# 5. Notify Emma
await bot.send_message(
    chat_id=emma_id,
    text=f"ðŸ“ Proposal needs revision\n\nJob #{job_id}\nFeedback: {revision_reason}",
    reply_markup=InlineKeyboardMarkup([[
        InlineKeyboardButton("âœ… Revised", callback_data=f"revision_done_{revision_task.id}")
    ]])
)

# 6. When Emma clicks "Revised", unblock review task
def on_revision_done(revision_task_id):
    # Mark revision complete
    graph.execute(f"""
        MATCH (revision:U4_Work_Item {{id: {revision_task_id}}})
        SET revision.state = 'complete'
    """)

    # Unblock review task
    graph.execute(f"""
        MATCH (review)-[blocker:U4_BLOCKED_BY]->(revision:U4_Work_Item {{id: {revision_task_id}}})
        DELETE blocker
        SET review.state = 'todo'
    """)

    # Notify Bigbosexf
    await bot.send_message(
        chat_id=bigbosexf_id,
        text=f"ðŸ“ Proposal revised. Ready for review again.",
        reply_markup=InlineKeyboardMarkup([[
            InlineKeyboardButton("âœ… Approve", callback_data=f"approve_proposal_{job_id}"),
            InlineKeyboardButton("âŒ Needs Revision", callback_data=f"revise_proposal_{job_id}")
        ]])
    )
```

---

### Pattern 2: Bugs Found in QA

**Trigger:** Bigbosexf clicks "Bugs Found" button on QA task

**Flow:**
```python
# 1. Prompt for bug description
await bot.send_message(
    chat_id=bigbosexf_id,
    text="Describe the bugs found:",
    reply_markup=ForceReply()
)

# 2. User types: "OTP doesn't work on iPhone Safari"
bug_description = await get_user_response()

# 3. Create bug fix task
bug_fix_task = create_task({
    "name": f"Fix bugs in Mission #{mission_id}",
    "work_type": "bug_fix",
    "priority": "critical",  # Higher than "high"
    "state": "todo",
    "assignee_ref": "kara",
    "pipeline_stage": "IMPLEMENTATION",
    "acceptance_criteria": "Bugs fixed and redeployed",
    "bug_description": bug_description
})

# 4. Block QA task
graph.execute(f"""
    MATCH (qa:U4_Work_Item {{name: "QA test Mission #{mission_id}"}})
    MATCH (fix:U4_Work_Item {{name: "Fix bugs in Mission #{mission_id}"}})
    CREATE (qa)-[:U4_BLOCKED_BY {{reason: bug_description}}]->(fix)
    SET qa.state = 'blocked'
""")

# 5. Notify Kara
await bot.send_message(
    chat_id=kara_id,
    text=f"ðŸ› Bugs found in Mission #{mission_id}\n\nDescription:\n{bug_description}",
    reply_markup=InlineKeyboardMarkup([[
        InlineKeyboardButton("âœ… Fixed & Deployed", callback_data=f"bugs_fixed_{bug_fix_task.id}")
    ]])
)

# 6. When Kara clicks "Fixed & Deployed", unblock QA task
def on_bugs_fixed(bug_fix_task_id):
    # Mark bug fix complete
    graph.execute(f"""
        MATCH (fix:U4_Work_Item {{id: {bug_fix_task_id}}})
        SET fix.state = 'complete'
    """)

    # Unblock QA task
    graph.execute(f"""
        MATCH (qa)-[blocker:U4_BLOCKED_BY]->(fix:U4_Work_Item {{id: {bug_fix_task_id}}})
        DELETE blocker
        SET qa.state = 'todo'
    """)

    # Notify Bigbosexf
    await bot.send_message(
        chat_id=bigbosexf_id,
        text=f"ðŸ› Bugs fixed and redeployed. Please re-test Mission #{mission_id}.",
        reply_markup=InlineKeyboardMarkup([[
            InlineKeyboardButton("âœ… QA Pass", callback_data=f"qa_pass_{mission_id}"),
            InlineKeyboardButton("ðŸ› More Bugs", callback_data=f"bugs_found_{mission_id}")
        ]])
    )
```

---

### Pattern 3: Spec Clarification Needed

**Trigger:** Kara clicks "Ask Question" button during implementation

**Flow:**
```python
# 1. Prompt for question
await bot.send_message(
    chat_id=kara_id,
    text="What's your question about the spec?",
    reply_markup=ForceReply()
)

# 2. User types: "Should login support Google OAuth or just email/password?"
question = await get_user_response()

# 3. Create clarification task
clarify_task = create_task({
    "name": f"Clarify spec for Mission #{mission_id}",
    "work_type": "clarification",
    "priority": "high",
    "state": "todo",
    "assignee_ref": "reanance",
    "pipeline_stage": "SPEC_WRITING",
    "acceptance_criteria": "Question answered, spec updated if needed",
    "question": question,
    "asked_by": "kara"
})

# 4. Block implementation task (optional - Kara can continue on other parts)
graph.execute(f"""
    MATCH (impl:U4_Work_Item {{name: "Implement Mission #{mission_id}"}})
    MATCH (clarify:U4_Work_Item {{name: "Clarify spec for Mission #{mission_id}"}})
    CREATE (impl)-[:U4_BLOCKED_BY {{reason: question, criticality: "preferred"}}]->(clarify)
    // Note: criticality = "preferred" means Kara can continue, but should wait for answer
""")

# 5. Notify Reanance
await bot.send_message(
    chat_id=reanance_id,
    text=f"ðŸ’¬ Kara has a question about Mission #{mission_id} spec:\n\n{question}",
    reply_markup=InlineKeyboardMarkup([[
        InlineKeyboardButton("ðŸ’¬ Answer", callback_data=f"answer_question_{clarify_task.id}")
    ]])
)

# 6. When Reanance clicks "Answer", prompt for response
def on_answer_question(clarify_task_id):
    await bot.send_message(
        chat_id=reanance_id,
        text="Type your answer:",
        reply_markup=ForceReply()
    )

    answer = await get_user_response()

    # Mark clarification complete
    graph.execute(f"""
        MATCH (clarify:U4_Work_Item {{id: {clarify_task_id}}})
        SET clarify.state = 'complete', clarify.answer = '{answer}'
    """)

    # Unblock implementation task
    graph.execute(f"""
        MATCH (impl)-[blocker:U4_BLOCKED_BY]->(clarify:U4_Work_Item {{id: {clarify_task_id}}})
        DELETE blocker
    """)

    # Send answer to Kara
    await bot.send_message(
        chat_id=kara_id,
        text=f"ðŸ’¬ Answer from Reanance:\n\n{question}\n\nAnswer:\n{answer}"
    )
```

---

## Event Triggers

### Trigger 1: Job Won

**Button click:** `job_won_{job_id}`

**Actions:**
1. Create mission node
2. Create 8 pipeline tasks
3. Encode dependencies
4. Send notifications to all assignees
5. Update mission state: `LEAD_FOUND` â†’ `JOB_WON` â†’ `SPEC_WRITING`

---

### Trigger 2: Job Lost

**Button click:** `job_lost_{job_id}`

**Actions:**
1. Update mission state: `PROPOSAL_SENT` â†’ `LOST`
2. Archive proposal
3. Update stats (loss rate, reasons)
4. No tasks created

---

### Trigger 3: Spec Complete

**Button click:** `spec_complete_{mission_id}`

**Actions:**
1. Complete Task 1 (Write spec)
2. Activate Task 2 (Implementation)
3. Send handoff brief to Kara (see `03-handoff-system-spec.md`)

---

### Trigger 4: Deploy Complete

**Button click:** `deploy_complete_{mission_id}`

**Actions:**
1. Complete Task 3 (Deploy)
2. Activate Task 4 (QA testing)
3. Send handoff brief to Bigbosexf

---

### Trigger 5: QA Pass

**Button click:** `qa_pass_{mission_id}`

**Actions:**
1. Complete Task 4 (QA testing)
2. Activate Task 5 (Client delivery)
3. Send handoff brief to Reanance
4. Tag GitHub repo: `ac-green_{mission_id}_{date}`

---

### Trigger 6: Client Delivery Complete

**Button click:** `delivery_complete_{mission_id}`

**Actions:**
1. Complete Task 5 (Client delivery)
2. Schedule Task 6 (Follow-up) for 7 days later
3. Update mission state: `CLIENT_DELIVERY` â†’ `COMPLETE`
4. Request payment confirmation

---

## Success Metrics

### Pipeline Creation Accuracy
- **Target:** 100% of won jobs create complete pipeline (8 tasks)
- **Measurement:** Count created tasks per mission
- **Failure threshold:** Missing tasks â†’ urgent bug fix

### Dependency Encoding
- **Target:** 0 orphaned tasks (tasks with no dependencies and no dependents)
- **Measurement:** Graph query for disconnected nodes
- **Failure threshold:** >0 orphaned tasks â†’ review dependency logic

### Revision Loop Efficiency
- **Target:** <2 revision cycles per proposal on average
- **Measurement:** Count revision tasks per mission
- **Failure threshold:** >3 revisions average â†’ review proposal templates

### Task Activation Latency
- **Target:** <1 minute from task completion to dependent task activation
- **Measurement:** `dependent.state_changed_at - blocker.completed_at`
- **Failure threshold:** >5 minutes â†’ check graph query performance

---

## Configuration

### Mission Template

**File:** `/automation/mission_template.py`

```python
PIPELINE_TASKS = [
    {
        "name_template": "Write spec for Mission #{mission_id}",
        "work_type": "specification",
        "assignee": "reanance",
        "state": "todo",
        "stage": "SPEC_WRITING",
        "depends_on": [],
        "due_offset_days": 2,
        "estimated_effort": "4h"
    },
    {
        "name_template": "Implement Mission #{mission_id}",
        "work_type": "implementation",
        "assignee": "kara",
        "state": "waiting",
        "stage": "IMPLEMENTATION",
        "depends_on": ["Write spec for Mission #{mission_id}"],
        "due_offset_days": 5,
        "estimated_effort": "8h"
    },
    # ... (remaining 6 tasks)
]
```

### Dependency Rules

**File:** `/automation/dependency_rules.py`

```python
DEPENDENCY_RULES = {
    "Implementation depends on Spec": {
        "source": "Implement Mission #*",
        "target": "Write spec for Mission #*",
        "criticality": "blocking",
        "reason": "Cannot implement without spec"
    },
    "Deployment depends on Implementation": {
        "source": "Deploy Mission #*",
        "target": "Implement Mission #*",
        "criticality": "blocking",
        "reason": "Cannot deploy without code"
    },
    "QA depends on Deployment": {
        "source": "QA test Mission #*",
        "target": "Deploy Mission #*",
        "criticality": "blocking",
        "reason": "Cannot test without live deployment"
    },
    # ... (remaining rules)
}
```

---

## Next Steps

**For Inna (Complete Documentation):**
Create 6-level docs from this spec (same structure as morning brief).

**For Rafael (Implementation):**
Once Inna's docs complete:
1. Generate `task_pipeline_engine.py` from ALGORITHM.md
2. Generate button handlers for job_won, spec_complete, etc.
3. Generate dependency logic from MECHANISM.md
4. Generate revision loop handlers

**For Alexis (Tracking):**
Add to roadmap:
- Milestone: Task Pipeline System
- Target: 2025-11-18
- Success criteria: 100% pipeline creation accuracy, <2 revision cycles

---

**Emma (Scout)**
ScopeLock â€” Automation Specifications
2025-11-06
